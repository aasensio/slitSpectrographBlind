import numpy as np
import matplotlib.pyplot as pl
from ipdb import set_trace as stop
import wavefront as wf
import scipy.io as scio
import pyiacsun as ps
import scipy.special as sp

def even(x):
    return x%2 == 0

class psf(object):
    def __init__(self, telescopeD, nPixPSF, nZernike, nSteps, nImages, tiptilt=False, fileName=None):
        self.telescopeD = telescopeD
        self.nPixPSF = nPixPSF
        self.nZernike = nZernike
        self.tiptilt = tiptilt
        if (self.tiptilt):
            self.zero = 2
        else:
            self.zero = 4
        self.nSteps = nSteps
        self.nImages = nImages
        self.fileName = fileName

        if (self.fileName is not None):
            self.f = scio.netcdf_file(fileName, 'w')
            self.f.createDimension('nPix', nPix)
            self.f.createDimension('nSteps', nSteps)
            self.f.createDimension('nImages', nImages)
            self.psf = self.f.createVariable('psf', 'd', ('nPix', 'nPix', 'nSteps', 'nImages'))
        else:
            self.psf = np.zeros((self.nPixPSF, self.nPixPSF, self.nSteps, self.nImages))

    def computeAperture(self, centralObs = 0, spider = 0):
        """
        Compute the aperture of the telescope
        
        Args:
            nPixPSF (int): size of the output aperture in pixel
            centralObs (int, optional): central obscuration
            spider (int, optional): spider size in pixel
        
        Returns:
        real: compute the aperture
        """
        self.aperture = wf.aperture(npix = self.nPixPSF, cent_obs = centralObs, spider=spider)

    def kolmogorov(self, r0):
        
        self.covariance = np.zeros((self.nZernike,self.nZernike))
        for i in range(self.nZernike):
            ni, mi = wf.nollIndices(i+self.zero)
            for j in range(self.nZernike):
                nj, mj = wf.nollIndices(j+self.zero)
                if (even(i - j)):
                    if (mi == mj):
                        phase = (-1.0)**(0.5*(ni+nj-2*mi))
                        t1 = np.sqrt((ni+1)*(nj+1)) * np.pi**(8.0/3.0) * 0.0072 * (self.telescopeD / r0)**(5.0/3.0)
                        t2 = sp.gamma(14./3.0) * sp.gamma(0.5*(ni+nj-5.0/3.0))
                        t3 = sp.gamma(0.5*(ni-nj+17.0/3.0)) * sp.gamma(0.5*(nj-ni+17.0/3.0)) * sp.gamma(0.5*(ni+nj+23.0/3.0))
                        self.covariance[i,j] = phase * t1 * t2 / t3

        self.coeff = np.random.multivariate_normal(np.zeros(self.nZernike), self.covariance, size=(self.nSteps, self.nImages))


    def precalculateZernike(self):
        self.zernike = np.zeros((self.nPixPSF,self.nPixPSF,self.nZernike))
        self.wavefront = np.zeros((self.nPixPSF,self.nPixPSF))
        for i in range(self.nZernike):
            self.zernike[:,:,i] = wf.zernike(i+self.zero, npix=self.nPixPSF)

    def generateSeeingPSF(self, lambda0, pixSize):
        """
        Compute a seeing PSF
        
        Args:
            aperture (float): aperture array generated by computeAperture
            telescopeDiameter (TYPE): telescope diameter [m]
            lambda0 (TYPE): wavelength [Angstrom]
            pixSize (TYPE): pixel size [arcsec]
            r0 (real): Fried parameter [cm]
            nterms (int): number of terms to include in the wavefront generation
        
        Returns:
        real: the final PSF
        """
        self.wavefront *= 0.0

        self.wavefront = np.einsum('ijk,lmk', self.zernike, self.coeff)

        loop = 0
        for i in range(self.nSteps):
            for j in range(self.nImages):
                ps.util.progressbar(loop, self.nSteps*self.nImages)
                self.psf[:,:,i,j] = wf.psf(self.aperture, self.wavefront[:,:,i,j], overfill = wf.psfScale(telescopeDiameter, lambda0, pixSize))                
                loop += 1
        
        return

    def close(self):
        if (self.fileName is not None):
            self.f.close()

telescopeDiameter = 1.51      # m
pixSize = 23.71 / 725.0      # arcsec
lambda0 = 6301.0             # Angstrom
r0 = 0.2                   # m
nPix = 64
nSteps = 128
nImages = 50

print("Computing PSF...")

out = psf(telescopeDiameter, nPix, 40, nSteps, nImages, fileName='/net/nas4/fis/aasensio/3dcubes/jaime/psfs.nf')
out.computeAperture(centralObs = 0.3, spider = 2)
out.precalculateZernike()
out.kolmogorov(r0)
out.generateSeeingPSF(lambda0, pixSize)
out.close()